#include "Module_Manager.h"
#include "logger.h"
#include <signal.h>
#include <stdlib.h>
#include "util.h"

// Define a module name for logging
#define MODULE_NAME "Main"
#define DEBUG
volatile int main_application_running = 1;

// Signal handler for graceful shutdown (Ctrl+C)
void handle_sigint(int sig) {
    LOG_INFO(MODULE_NAME, "SIGINT received, initiating graceful shutdown...");
    main_application_running = 0; // Set the flag to stop main loop
}

// Shutdown check callback for the module manager
int check_app_shutdown_status(void) {
    return !main_application_running;
}

int main(void) {
    if (!logger_init(8192, 80)) {
   
        fprintf(stderr, "Failed to initialize logger. Exiting.\n");
        return EXIT_FAILURE;
    }
    
    // Set up signal handler
    signal(SIGINT, handle_sigint);
    
    // Initialize all modules through the module manager
    if (SUCCESS != ModuleManager_init()) {
        error_info_t err = {
            .code = FAIL,
            .description = "Module initialization failed. Exiting."
        };
        LOG_ERROR_CODE(MODULE_NAME, err);
        logger_shutdown();
        return EXIT_FAILURE;
    }
    
    // Log successful initialization
    LOG_INFO(MODULE_NAME, "All modules initialized. Press Ctrl+C to shut down.");
    
    // Run the main application loop through the module manager
    int app_status = ModuleManager_run(check_app_shutdown_status);
    
    // Perform a clean shutdown regardless of how we exited the loop
    LOG_INFO(MODULE_NAME, "Initiating application shutdown...");
    
   if (FAIL == app_status) {
        error_info_t err = {
            .code = app_status,
            .description = "Application terminated with an error."
        };
        LOG_ERROR_CODE(MODULE_NAME, err);
   }
   if(ModuleManager_shutdown() != SUCCESS) {
        error_info_t err = {
            .code = FAIL,
            .description = "Module shutdown failed."
        };
        LOG_ERROR_CODE(MODULE_NAME, err);
         logger_shutdown();
        return EXIT_FAILURE;
    } else {
        LOG_INFO(MODULE_NAME, "Application shutdown complete. Goodbye!");
        logger_flush(); // Ensure all logs are written
        logger_shutdown();
        return EXIT_SUCCESS;
    }
}

i created amodule for logging 
logger.h
#ifndef LOGGER_H
#define LOGGER_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h> // Needed for snprintf in LOG_ERROR_CODE macro

// Log levels
typedef enum {
    LOG_LEVEL_ERROR = 0,
    LOG_LEVEL_WARN,
    LOG_LEVEL_INFO,
    LOG_LEVEL_DEBUG,
    LOG_LEVEL_TRACE
} log_level_t;

// Log entry structure (potentially needed externally)
typedef struct {
    log_level_t level;
    const char* module;
    const char* message;
    uint32_t line;
    const char* file;
    uint64_t timestamp; // Assuming milliseconds since epoch
} log_entry_t;

// Error info structure (potentially needed externally)
typedef struct {
    int code;
    const char* description;
} error_info_t;


// Log output handler function pointer type
typedef void (*log_output_handler_t)(const log_entry_t* entry);

// --- Core Logger Functions ---
// These functions will have stub implementations in release mode

// Initialize the logger
// buffer_size: Size of the internal log entry buffer in bytes.
// flush_threshold: Percentage (0-100) of buffer fullness to trigger auto-flush. 0 disables auto-flush.
bool logger_init(size_t buffer_size, uint8_t flush_threshold);

// Set the minimum log level to record. Messages below this level are ignored.
void logger_set_level(log_level_t level);

// Set a custom output handler. Pass NULL to revert to the default handler (prints to stderr).
void logger_set_output_handler(log_output_handler_t handler);

// Manually flush all buffered log entries to the output handler.
void logger_flush(void);

// Shut down the logger, flush remaining entries, and release resources.
void logger_shutdown(void);

// --- Conditional Logging Macros ---

#ifdef DEBUG
    // Internal function prototype (only needed in debug mode)
    void logger_log(log_level_t level, const char* module, const char* file, uint32_t line, const char* message);

    // Logging macros - expand to function calls in debug mode
    #define LOG_ERROR(module, message) logger_log(LOG_LEVEL_ERROR, module, __FILE__, __LINE__, message)
    #define LOG_WARN(module, message)  logger_log(LOG_LEVEL_WARN,  module, __FILE__, __LINE__, message)
    #define LOG_INFO(module, message)  logger_log(LOG_LEVEL_INFO,  module, __FILE__, __LINE__, message)
    #define LOG_DEBUG(module, message) logger_log(LOG_LEVEL_DEBUG, module, __FILE__, __LINE__, message)
    #define LOG_TRACE(module, message) logger_log(LOG_LEVEL_TRACE, module, __FILE__, __LINE__, message)

    // Helper macro for logging error_info_t
    // Formats the error code and description into a single string before logging.
    #define LOG_ERROR_CODE(module, error_info) do { \
        char _err_msg[256]; \
        snprintf(_err_msg, sizeof(_err_msg), "Error Code %d: %s", (error_info).code, (error_info).description ? (error_info).description : "(no description)"); \
        logger_log(LOG_LEVEL_ERROR, module, __FILE__, __LINE__, _err_msg); \
    } while(0)

#else // NOT DEBUG
    // Logging macros - expand to nothing in release mode
    #define LOG_ERROR(module, message) ((void)0)
    #define LOG_WARN(module, message)  ((void)0)
    #define LOG_INFO(module, message)  ((void)0)
    #define LOG_DEBUG(module, message) ((void)0)
    #define LOG_TRACE(module, message) ((void)0)
    #define LOG_ERROR_CODE(module, error_info) ((void)0)

#endif // DEBUG

#endif // LOGGER_H


i need to use this module just for debugging mode not always
MAKE$ make
gcc -Wall -Wextra -g  -I../INC ../OBJ/assert_handler.o ../OBJ/ComCalSinCos.o ../OBJ/error.o ../OBJ/ipc.o ../OBJ/main2.o ../OBJ/Module_Manager.o ../OBJ/Ring_Buffer.o ../OBJ/State_Machine.o ../OBJ/util.o -lm -lcjson -o ../BIN/sv_simulator
/usr/bin/ld: ../OBJ/main2.o: in function `handle_sigint':
/media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:14: undefined reference to `logger_log'
/usr/bin/ld: ../OBJ/main2.o: in function `main':
/media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:24: undefined reference to `logger_init'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:39: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:40: undefined reference to `logger_shutdown'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:45: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:51: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:58: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:65: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:66: undefined reference to `logger_shutdown'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:69: undefined reference to `logger_log'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:70: undefined reference to `logger_flush'
/usr/bin/ld: /media/eya/data/Test_tool/C_application/MAKE/../SRC/main2.c:71: undefined reference to `logger_shutdown'
collect2: error: ld returned 1 exit status
make: *** [Makefile:32: ../BIN/sv_simulator] Error 1
help me solve the problem
